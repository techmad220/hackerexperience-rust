//! Loggable event system for generating log entries

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

use crate::{Event, EventResult};

/// Log entry generated by loggable events
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogEntry {
    pub server_id: Uuid,
    pub entity_id: Uuid,
    pub log_type: LogType,
    pub message: String,
    pub data: HashMap<String, serde_json::Value>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

/// Types of log entries
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum LogType {
    Connection,
    LoginAttempt,
    FileAccess,
    ProcessStarted,
    ProcessCompleted,
    SecurityAlert,
    SystemEvent,
    Custom(String),
}

impl LogEntry {
    /// Create a new log entry
    pub fn new(
        server_id: Uuid,
        entity_id: Uuid,
        log_type: LogType,
        message: impl Into<String>,
    ) -> Self {
        Self {
            server_id,
            entity_id,
            log_type,
            message: message.into(),
            data: HashMap::new(),
            timestamp: chrono::Utc::now(),
        }
    }

    /// Add data to the log entry
    pub fn with_data(mut self, key: impl Into<String>, value: impl Serialize) -> Self {
        if let Ok(json_value) = serde_json::to_value(value) {
            self.data.insert(key.into(), json_value);
        }
        self
    }
}

/// Trait for events that can generate log entries
#[async_trait]
pub trait Loggable: Event {
    /// Generate log entries for this event
    async fn generate_logs(&self) -> EventResult<Vec<LogEntry>>;
}

/// Flow handler for saving log entries
pub struct LoggableFlow;

impl LoggableFlow {
    /// Save log entries to the database/storage
    pub async fn save_logs(entries: Vec<LogEntry>) -> EventResult<()> {
        for entry in &entries {
            tracing::info!(
                "Logging entry: server={}, type={:?}, message={}",
                entry.server_id,
                entry.log_type,
                entry.message
            );
            // In a real implementation, this would save to database
        }
        
        tracing::debug!("Saved {} log entries", entries.len());
        Ok(())
    }

    /// Process loggable event and save its log entries
    pub async fn process_event<T: Loggable>(event: &T) -> EventResult<()> {
        let log_entries = event.generate_logs().await?;
        Self::save_logs(log_entries).await
    }
}

/// Utility functions for log generation
pub mod utils {
    use super::*;

    /// Create a connection log entry
    pub fn connection_log(
        server_id: Uuid,
        entity_id: Uuid,
        connected: bool,
        source_ip: Option<String>,
    ) -> LogEntry {
        let message = if connected {
            "Connection established"
        } else {
            "Connection terminated"
        };

        let mut entry = LogEntry::new(server_id, entity_id, LogType::Connection, message);
        
        if let Some(ip) = source_ip {
            entry = entry.with_data("source_ip", ip);
        }
        entry = entry.with_data("connected", connected);
        
        entry
    }

    /// Create a file access log entry
    pub fn file_access_log(
        server_id: Uuid,
        entity_id: Uuid,
        file_path: impl Into<String>,
        action: impl Into<String>,
    ) -> LogEntry {
        let file_path = file_path.into();
        let action = action.into();
        let message = format!("File {} {}", action, file_path);

        LogEntry::new(server_id, entity_id, LogType::FileAccess, message)
            .with_data("file_path", file_path)
            .with_data("action", action)
    }

    /// Create a process log entry
    pub fn process_log(
        server_id: Uuid,
        entity_id: Uuid,
        process_type: impl Into<String>,
        started: bool,
    ) -> LogEntry {
        let process_type = process_type.into();
        let log_type = if started {
            LogType::ProcessStarted
        } else {
            LogType::ProcessCompleted
        };
        
        let message = format!("Process {} {}", 
            process_type,
            if started { "started" } else { "completed" }
        );

        LogEntry::new(server_id, entity_id, log_type, message)
            .with_data("process_type", process_type)
            .with_data("started", started)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_log_entry_creation() {
        let server_id = Uuid::new_v4();
        let entity_id = Uuid::new_v4();
        
        let entry = LogEntry::new(
            server_id,
            entity_id,
            LogType::Connection,
            "Test message"
        ).with_data("test_key", "test_value");

        assert_eq!(entry.server_id, server_id);
        assert_eq!(entry.entity_id, entity_id);
        assert_eq!(entry.message, "Test message");
        assert!(entry.data.contains_key("test_key"));
    }

    #[test]
    fn test_connection_log_utils() {
        let server_id = Uuid::new_v4();
        let entity_id = Uuid::new_v4();
        
        let log = utils::connection_log(
            server_id,
            entity_id,
            true,
            Some("192.168.1.1".to_string())
        );

        assert_eq!(log.server_id, server_id);
        assert_eq!(log.message, "Connection established");
        assert!(matches!(log.log_type, LogType::Connection));
        assert!(log.data.contains_key("source_ip"));
        assert!(log.data.contains_key("connected"));
    }

    #[tokio::test]
    async fn test_loggable_flow() {
        let entries = vec![
            LogEntry::new(
                Uuid::new_v4(),
                Uuid::new_v4(),
                LogType::SystemEvent,
                "Test log"
            )
        ];

        let result = LoggableFlow::save_logs(entries).await;
        assert!(result.is_ok());
    }
}