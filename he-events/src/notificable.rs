//! Notificable event system for generating notifications

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

use crate::{Event, EventResult};

/// Notification generated by notificable events
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationEntry {
    pub account_id: Uuid,
    pub notification_class: NotificationClass,
    pub notification_code: String,
    pub data: HashMap<String, serde_json::Value>,
    pub target_id: Option<Uuid>, // server_id, chat_id, entity_id depending on class
}

/// Notification classes
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum NotificationClass {
    Server,
    Chat,
    Entity,
}

impl NotificationEntry {
    /// Create a new notification entry
    pub fn new(
        account_id: Uuid,
        class: NotificationClass,
        code: impl Into<String>,
    ) -> Self {
        Self {
            account_id,
            notification_class: class,
            notification_code: code.into(),
            data: HashMap::new(),
            target_id: None,
        }
    }

    /// Add data to the notification
    pub fn with_data(mut self, key: impl Into<String>, value: impl Serialize) -> Self {
        if let Ok(json_value) = serde_json::to_value(value) {
            self.data.insert(key.into(), json_value);
        }
        self
    }

    /// Set target ID (server, chat, or entity)
    pub fn with_target(mut self, target_id: Uuid) -> Self {
        self.target_id = Some(target_id);
        self
    }
}

/// Trait for events that can generate notifications
#[async_trait]
pub trait Notificable: Event {
    /// Generate notification entries for this event
    async fn generate_notifications(&self) -> EventResult<Vec<NotificationEntry>>;
}

/// Flow handler for processing notifications
pub struct NotificableFlow;

impl NotificableFlow {
    /// Process notification entries
    pub async fn process_notifications(entries: Vec<NotificationEntry>) -> EventResult<()> {
        for entry in &entries {
            tracing::info!(
                "Processing notification: account={}, class={:?}, code={}",
                entry.account_id,
                entry.notification_class,
                entry.notification_code
            );
            // In a real implementation, this would create notifications in the database
            // and potentially send them via WebSocket
        }
        
        tracing::debug!("Processed {} notifications", entries.len());
        Ok(())
    }

    /// Process notificable event and handle its notifications
    pub async fn process_event<T: Notificable>(event: &T) -> EventResult<()> {
        let notifications = event.generate_notifications().await?;
        Self::process_notifications(notifications).await
    }
}

/// Utility functions for notification generation
pub mod utils {
    use super::*;

    /// Create a server notification
    pub fn server_notification(
        account_id: Uuid,
        server_id: Uuid,
        code: impl Into<String>,
        message: impl Into<String>,
    ) -> NotificationEntry {
        NotificationEntry::new(account_id, NotificationClass::Server, code)
            .with_target(server_id)
            .with_data("message", message.into())
    }

    /// Create a chat notification
    pub fn chat_notification(
        account_id: Uuid,
        chat_id: Uuid,
        code: impl Into<String>,
        from_user: Option<String>,
        message: impl Into<String>,
    ) -> NotificationEntry {
        let mut notification = NotificationEntry::new(account_id, NotificationClass::Chat, code)
            .with_target(chat_id)
            .with_data("message", message.into());
        
        if let Some(from) = from_user {
            notification = notification.with_data("from_user", from);
        }
        
        notification
    }

    /// Create an entity notification
    pub fn entity_notification(
        account_id: Uuid,
        entity_id: Uuid,
        code: impl Into<String>,
        title: impl Into<String>,
        description: impl Into<String>,
    ) -> NotificationEntry {
        NotificationEntry::new(account_id, NotificationClass::Entity, code)
            .with_target(entity_id)
            .with_data("title", title.into())
            .with_data("description", description.into())
    }

    /// Create achievement notification
    pub fn achievement_notification(
        account_id: Uuid,
        entity_id: Uuid,
        achievement_name: impl Into<String>,
        achievement_description: impl Into<String>,
    ) -> NotificationEntry {
        let name = achievement_name.into();
        let description = achievement_description.into();
        
        NotificationEntry::new(account_id, NotificationClass::Entity, "achievement_unlocked")
            .with_target(entity_id)
            .with_data("achievement_name", name)
            .with_data("achievement_description", description)
            .with_data("title", "Achievement Unlocked!")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_notification_entry_creation() {
        let account_id = Uuid::new_v4();
        let server_id = Uuid::new_v4();
        
        let notification = NotificationEntry::new(
            account_id,
            NotificationClass::Server,
            "connection_lost"
        )
        .with_target(server_id)
        .with_data("message", "Server connection lost");

        assert_eq!(notification.account_id, account_id);
        assert_eq!(notification.target_id, Some(server_id));
        assert_eq!(notification.notification_code, "connection_lost");
        assert!(notification.data.contains_key("message"));
    }

    #[test]
    fn test_notification_utils() {
        let account_id = Uuid::new_v4();
        let server_id = Uuid::new_v4();
        
        let notification = utils::server_notification(
            account_id,
            server_id,
            "login_attempt",
            "Failed login attempt detected"
        );

        assert_eq!(notification.account_id, account_id);
        assert_eq!(notification.target_id, Some(server_id));
        assert_eq!(notification.notification_code, "login_attempt");
        assert!(matches!(notification.notification_class, NotificationClass::Server));
    }

    #[tokio::test]
    async fn test_notificable_flow() {
        let notifications = vec![
            NotificationEntry::new(
                Uuid::new_v4(),
                NotificationClass::Entity,
                "test_notification"
            )
        ];

        let result = NotificableFlow::process_notifications(notifications).await;
        assert!(result.is_ok());
    }
}