//! Alliance System - Multiple clans working together

use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::{HashMap, HashSet};

use crate::clan::{Clan, ClanWar};

/// Alliance of multiple clans
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Alliance {
    pub id: Uuid,
    pub name: String,
    pub description: String,
    pub leader_clan: Uuid,
    pub member_clans: HashSet<Uuid>,
    pub pending_invites: HashSet<Uuid>,
    pub created_at: DateTime<Utc>,
    pub power_rating: u64,
    pub territories: Vec<AllianceTerritory>,
    pub diplomacy: HashMap<Uuid, DiplomaticStatus>,
    pub treasury: i64,
    pub research: AllianceResearch,
    pub active_wars: Vec<AllianceWar>,
}

/// Territory controlled by alliance
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AllianceTerritory {
    pub id: String,
    pub name: String,
    pub zone: TerritoryZone,
    pub control_points: u32,
    pub fortification_level: u32,
    pub resource_generation: ResourceGeneration,
    pub defending_clan: Option<Uuid>,
    pub under_attack: bool,
}

/// Territory zones
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TerritoryZone {
    Core,      // Central, well-defended
    Border,    // Edge territories
    Contested, // Disputed areas
    Neutral,   // Unclaimed
}

/// Resources generated by territory
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceGeneration {
    pub money_per_hour: i64,
    pub experience_per_hour: u32,
    pub research_points_per_hour: u32,
    pub special_resources: Vec<String>,
}

/// Diplomatic status with another alliance
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DiplomaticStatus {
    Allied,
    Friendly,
    Neutral,
    Hostile,
    AtWar,
}

/// Alliance research tree
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AllianceResearch {
    pub research_points: u32,
    pub completed_techs: HashSet<String>,
    pub current_research: Option<ResearchProject>,
    pub tech_tree: TechTree,
}

/// Research project
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResearchProject {
    pub tech_id: String,
    pub name: String,
    pub progress: u32,
    pub required_points: u32,
    pub started_at: DateTime<Utc>,
    pub contributors: HashMap<Uuid, u32>, // Clan ID -> points contributed
}

/// Technology tree
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TechTree {
    pub military_techs: Vec<Technology>,
    pub economic_techs: Vec<Technology>,
    pub espionage_techs: Vec<Technology>,
    pub defensive_techs: Vec<Technology>,
}

/// Individual technology
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Technology {
    pub id: String,
    pub name: String,
    pub description: String,
    pub cost: u32,
    pub prerequisites: Vec<String>,
    pub bonuses: TechBonuses,
}

/// Bonuses from technology
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TechBonuses {
    pub attack_bonus: f32,
    pub defense_bonus: f32,
    pub economy_bonus: f32,
    pub spy_effectiveness: f32,
    pub special_abilities: Vec<String>,
}

/// Large-scale war between alliances
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AllianceWar {
    pub id: Uuid,
    pub attackers: AllianceCoalition,
    pub defenders: AllianceCoalition,
    pub status: WarPhase,
    pub started_at: DateTime<Utc>,
    pub current_phase_ends: DateTime<Utc>,
    pub war_goals: Vec<WarGoal>,
    pub battles: Vec<Battle>,
    pub war_score: WarScore,
}

/// Coalition in war
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AllianceCoalition {
    pub leader_alliance: Uuid,
    pub member_alliances: HashSet<Uuid>,
    pub total_power: u64,
    pub morale: i32,
    pub war_exhaustion: f32,
}

/// War phases
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum WarPhase {
    Declaration,    // 24h preparation
    Skirmish,      // Small battles
    MainCampaign,  // Full warfare
    FinalPush,     // Decisive battles
    Resolution,    // War ending
}

/// War goal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WarGoal {
    ConquerTerritory { territory_id: String },
    Humiliate { target_alliance: Uuid },
    Tribute { amount: i64 },
    Disband { target_alliance: Uuid },
    Liberation { clan_id: Uuid },
}

/// Battle in alliance war
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Battle {
    pub id: Uuid,
    pub battle_type: BattleType,
    pub location: String,
    pub attackers: BattleForce,
    pub defenders: BattleForce,
    pub started_at: DateTime<Utc>,
    pub duration: u64,
    pub outcome: Option<BattleOutcome>,
}

/// Type of battle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BattleType {
    TerritoryAssault,
    TerritoryDefense,
    RaidMission,
    Sabotage,
    NavalBattle,
    CyberWarfare,
}

/// Forces in battle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BattleForce {
    pub clans: Vec<Uuid>,
    pub total_members: u32,
    pub average_level: u32,
    pub morale: i32,
    pub casualties: u32,
}

/// Battle outcome
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BattleOutcome {
    pub victor: String, // "attackers" or "defenders"
    pub territory_captured: bool,
    pub casualties: (u32, u32), // (attacker, defender)
    pub loot: i64,
    pub experience_gained: u32,
}

/// War score tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WarScore {
    pub attacker_score: i32,
    pub defender_score: i32,
    pub battles_won: (u32, u32),
    pub territories_captured: (u32, u32),
    pub economic_damage: (i64, i64),
}

/// Espionage operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EspionageOperation {
    pub id: Uuid,
    pub operation_type: OperationType,
    pub source_alliance: Uuid,
    pub target_alliance: Uuid,
    pub assigned_spies: Vec<Uuid>,
    pub progress: f32,
    pub success_chance: f32,
    pub started_at: DateTime<Utc>,
    pub completes_at: DateTime<Utc>,
}

/// Types of espionage operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OperationType {
    IntelGathering,
    Sabotage { target: String },
    Assassination { target_id: Uuid },
    TechnologyTheft { tech_id: String },
    PropagandaCampaign,
    FalseFlag, // Blame another alliance
    Defection { target_clan: Uuid },
}

impl Alliance {
    /// Create new alliance
    pub fn new(name: String, leader_clan: Uuid) -> Self {
        let mut member_clans = HashSet::new();
        member_clans.insert(leader_clan);

        Self {
            id: Uuid::new_v4(),
            name,
            description: String::new(),
            leader_clan,
            member_clans,
            pending_invites: HashSet::new(),
            created_at: Utc::now(),
            power_rating: 0,
            territories: Vec::new(),
            diplomacy: HashMap::new(),
            treasury: 0,
            research: AllianceResearch::new(),
            active_wars: Vec::new(),
        }
    }

    /// Invite clan to alliance
    pub fn invite_clan(&mut self, clan_id: Uuid) -> Result<(), AllianceError> {
        if self.member_clans.contains(&clan_id) {
            return Err(AllianceError::AlreadyMember);
        }

        self.pending_invites.insert(clan_id);
        Ok(())
    }

    /// Accept clan into alliance
    pub fn accept_clan(&mut self, clan_id: Uuid) -> Result<(), AllianceError> {
        if !self.pending_invites.contains(&clan_id) {
            return Err(AllianceError::NoInvite);
        }

        self.pending_invites.remove(&clan_id);
        self.member_clans.insert(clan_id);
        self.recalculate_power();

        Ok(())
    }

    /// Remove clan from alliance
    pub fn remove_clan(&mut self, clan_id: Uuid) -> Result<(), AllianceError> {
        if clan_id == self.leader_clan {
            return Err(AllianceError::CannotRemoveLeader);
        }

        if !self.member_clans.contains(&clan_id) {
            return Err(AllianceError::NotAMember);
        }

        self.member_clans.remove(&clan_id);
        self.recalculate_power();

        Ok(())
    }

    /// Declare war on another alliance
    pub fn declare_war(&mut self, target_alliance: Uuid, war_goals: Vec<WarGoal>) -> AllianceWar {
        let coalition = AllianceCoalition {
            leader_alliance: self.id,
            member_alliances: HashSet::new(),
            total_power: self.power_rating,
            morale: 100,
            war_exhaustion: 0.0,
        };

        let war = AllianceWar {
            id: Uuid::new_v4(),
            attackers: coalition.clone(),
            defenders: coalition, // Would be filled with target alliance data
            status: WarPhase::Declaration,
            started_at: Utc::now(),
            current_phase_ends: Utc::now() + chrono::Duration::hours(24),
            war_goals,
            battles: Vec::new(),
            war_score: WarScore {
                attacker_score: 0,
                defender_score: 0,
                battles_won: (0, 0),
                territories_captured: (0, 0),
                economic_damage: (0, 0),
            },
        };

        self.active_wars.push(war.clone());
        self.diplomacy.insert(target_alliance, DiplomaticStatus::AtWar);

        war
    }

    /// Capture territory
    pub fn capture_territory(&mut self, territory: AllianceTerritory) {
        self.territories.push(territory);
        self.recalculate_power();
    }

    /// Recalculate alliance power
    fn recalculate_power(&mut self) {
        // Base power from member count
        let member_power = self.member_clans.len() as u64 * 1000;

        // Territory power
        let territory_power = self.territories.len() as u64 * 500;

        // Research power
        let research_power = self.research.completed_techs.len() as u64 * 200;

        self.power_rating = member_power + territory_power + research_power;
    }

    /// Start research project
    pub fn start_research(&mut self, tech_id: String) -> Result<(), AllianceError> {
        if self.research.current_research.is_some() {
            return Err(AllianceError::ResearchInProgress);
        }

        // Find tech in tree
        let tech = self.find_technology(&tech_id)
            .ok_or(AllianceError::TechNotFound)?;

        // Check prerequisites
        for prereq in &tech.prerequisites {
            if !self.research.completed_techs.contains(prereq) {
                return Err(AllianceError::MissingPrerequisites);
            }
        }

        self.research.current_research = Some(ResearchProject {
            tech_id,
            name: tech.name.clone(),
            progress: 0,
            required_points: tech.cost,
            started_at: Utc::now(),
            contributors: HashMap::new(),
        });

        Ok(())
    }

    /// Find technology in tree
    fn find_technology(&self, tech_id: &str) -> Option<Technology> {
        self.research.tech_tree.military_techs.iter()
            .chain(self.research.tech_tree.economic_techs.iter())
            .chain(self.research.tech_tree.espionage_techs.iter())
            .chain(self.research.tech_tree.defensive_techs.iter())
            .find(|t| t.id == tech_id)
            .cloned()
    }

    /// Contribute to research
    pub fn contribute_research(&mut self, clan_id: Uuid, points: u32) -> Result<(), AllianceError> {
        if !self.member_clans.contains(&clan_id) {
            return Err(AllianceError::NotAMember);
        }

        if let Some(ref mut research) = self.research.current_research {
            research.progress += points;
            *research.contributors.entry(clan_id).or_insert(0) += points;

            // Check if completed
            if research.progress >= research.required_points {
                let tech_id = research.tech_id.clone();
                self.research.completed_techs.insert(tech_id);
                self.research.current_research = None;
            }
        }

        Ok(())
    }
}

impl AllianceResearch {
    fn new() -> Self {
        Self {
            research_points: 0,
            completed_techs: HashSet::new(),
            current_research: None,
            tech_tree: TechTree::default(),
        }
    }
}

impl Default for TechTree {
    fn default() -> Self {
        Self {
            military_techs: vec![
                Technology {
                    id: "advanced_warfare".to_string(),
                    name: "Advanced Warfare".to_string(),
                    description: "Improves all combat effectiveness".to_string(),
                    cost: 1000,
                    prerequisites: vec![],
                    bonuses: TechBonuses {
                        attack_bonus: 0.15,
                        defense_bonus: 0.10,
                        economy_bonus: 0.0,
                        spy_effectiveness: 0.0,
                        special_abilities: vec!["blitzkrieg".to_string()],
                    },
                },
            ],
            economic_techs: vec![
                Technology {
                    id: "trade_routes".to_string(),
                    name: "Trade Routes".to_string(),
                    description: "Increases resource generation".to_string(),
                    cost: 800,
                    prerequisites: vec![],
                    bonuses: TechBonuses {
                        attack_bonus: 0.0,
                        defense_bonus: 0.0,
                        economy_bonus: 0.25,
                        spy_effectiveness: 0.0,
                        special_abilities: vec!["merchant_guild".to_string()],
                    },
                },
            ],
            espionage_techs: vec![
                Technology {
                    id: "deep_cover".to_string(),
                    name: "Deep Cover Agents".to_string(),
                    description: "Improves spy operations".to_string(),
                    cost: 1200,
                    prerequisites: vec![],
                    bonuses: TechBonuses {
                        attack_bonus: 0.0,
                        defense_bonus: 0.0,
                        economy_bonus: 0.0,
                        spy_effectiveness: 0.30,
                        special_abilities: vec!["double_agent".to_string()],
                    },
                },
            ],
            defensive_techs: vec![
                Technology {
                    id: "fortress_doctrine".to_string(),
                    name: "Fortress Doctrine".to_string(),
                    description: "Improves defensive capabilities".to_string(),
                    cost: 900,
                    prerequisites: vec![],
                    bonuses: TechBonuses {
                        attack_bonus: 0.0,
                        defense_bonus: 0.25,
                        economy_bonus: 0.0,
                        spy_effectiveness: 0.0,
                        special_abilities: vec!["last_stand".to_string()],
                    },
                },
            ],
        }
    }
}

/// Alliance errors
#[derive(Debug, thiserror::Error)]
pub enum AllianceError {
    #[error("Clan is already a member")]
    AlreadyMember,
    #[error("Clan has no invite")]
    NoInvite,
    #[error("Not a member of alliance")]
    NotAMember,
    #[error("Cannot remove alliance leader")]
    CannotRemoveLeader,
    #[error("Research already in progress")]
    ResearchInProgress,
    #[error("Technology not found")]
    TechNotFound,
    #[error("Missing prerequisites")]
    MissingPrerequisites,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_alliance() {
        let leader_clan = Uuid::new_v4();
        let mut alliance = Alliance::new("Test Alliance".to_string(), leader_clan);

        assert!(alliance.member_clans.contains(&leader_clan));

        // Test inviting clan
        let new_clan = Uuid::new_v4();
        assert!(alliance.invite_clan(new_clan).is_ok());
        assert!(alliance.pending_invites.contains(&new_clan));

        // Accept clan
        assert!(alliance.accept_clan(new_clan).is_ok());
        assert!(alliance.member_clans.contains(&new_clan));
    }
}